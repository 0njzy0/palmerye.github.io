<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[如何在Windows下像Mac一样优雅开发]]></title>
      <url>%2F%E5%A6%82%E4%BD%95%E5%9C%A8Windows%E4%B8%8B%E5%83%8FMac%E4%B8%80%E6%A0%B7%E4%BC%98%E9%9B%85%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[起因：之前一直用Mac开发，换了家公司，只许用Windows下开发，说实话，一开始我是拒绝的，可自从看到了这几个工具以后…… 下文大标题说明：（Mac下的工具）VS（Windows下的工具），Mac下的工具说明会简要点，毕竟看文章的基本上都是实在受不了Windows的重度Mac开发者。 1. item2 VS Cmder 终端工具 - iterm2iterm2是Mac下最好用的终端工具，听说没有之一。配合oh-my-zsh,你的终端居然可以这样！震惊！！（UC震惊部） 池建强大大有一篇文章《终极 Shell》讲mac下的终端，讲的比较好，贴这。大家可以做取舍。 - Cmder 如果你用过Windows自带的cmd，简直想shi有没有！页面丑就算了！没有tab！窗口不能缩放！不能用鼠标复制文本！！@#￥%&amp;*￥%…%￥ Cmder绝对是一款Windows环境下的cmd替代者，支持了大部分的Linux命令。 支持tab标签 集成git 支持绝大Unix/Linux命令 但是安装之后一般都会有以下几个问题： 中文乱码问题 文字重叠问题 λ其实可以替换成$ 2. Homebrew VS Chocolatey 包管理工具 - Homebrew为什么要用Homebrew？官网讲得很露骨，一款macOS缺失的软件包管理器 安装Homebrew：命令行输入1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 举个栗子，如果你要安装sublimeText，你可以这样：1brew install sublime-text 再优雅点，你可以安装Homebrew的命令行工具homebrew-cask12345brew tap phinze/homebrew-cask &amp;&amp; brew install brew-cask然后你可以这样愉快地安装一堆软件brew cask install sublime-text skitch dropbox google-chrome 用Homebrew安装软件有什么好处么？ 将软件包安装到独立目录，并将其文件软链接至 /usr/local 不会将文件安装到它本身目录之外，所以您可将 Homebrew 安装到任意位置 完全基于git和ruby，所以自由修改的同时你仍可以轻松撤销你的变更或与上游更新合并 - ChocolateyChocolatey官网是这么介绍自己的，The package manager for Windows. 安装嘿嘿，这个时候打开上面提到的cmder命令行工具，输入: 1@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot; 这个时候如果你也要装sublimeText3，你也可以这样！1choco install SublimeText3 是不是很酷！好处同上，具体的配置自行琢磨，这个时候已经和Mac下的体验很接近了。让我们再近一步！~ 3. Spotlight VS Listary 文件浏览增强工具 - Spotlight自从升级到macOS Sierra后，其实mac自带的Spotlight已经很强大了，至于类似Alfred的神器，我倒觉得一般用户没必要折腾了，当然你想更Geek点，可以折腾下Alfred，毕竟那样看起来很酷！ 安利VueJs时刻！ - Listary Listary的出现，让突然从Mac转向Windows开发的我产生的强烈排斥心理得到了一定的缓解！ 先说说效果经过我的配置，我想要打开某一软件或者文件，双击Ctrl，弹出Listary小窗，输入几个模糊关键字，回车！仿佛置身于Mac有没有！！ 下载安装官网有free版和Pro版，至于破解还是支持正版… 界面举栗 如果你是Mac用户，我想是无缝衔接的，配置快捷键后，效率也是极高的！ 4. Clover 给Windows资源管理器加上Tab标签 不知道Windows用户有没有注意到，每次打开我的电脑，会弹出一个新的窗口，再打开，再弹！再打开！再弹！循环个几次，桌面上会有一堆“我的电脑”窗口，是的，一堆……一堆……堆…… 所以你需要一个类似chrome标签一样的工具，帮你窗口整合。这就是[Clover]唯一的作用。 Clover下载地址 同样的，你可以将常用的地址存为标签，类似浏览器收藏夹，方便下次打开。 继续寻觅中……对我来说，应该是对于绝大部分开发者来说，开发环境的舒适是很重要的，想方设法提高效率，我倒觉得折腾这些工具也是挺有必要的。 应该会持续更新吧，毕竟Windows下坑还很多。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git工作流之一(集中式工作流)]]></title>
      <url>%2FGit%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%B9%8B%E4%B8%80--%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%2F</url>
      <content type="text"><![CDATA[引言一言不合讲个小故事 一个和尚有水喝，两个和尚挑水喝，三个和尚没水喝。 故事暴露了团队协作的问题，但接下来的故事与和尚无关，只是讲讲团队协作的事儿。 贯穿全文的角色 老A：技术Leader 阿B：工程师 小C：实习生 Git工作流 Git是Linux老爹的强大发明之一，用C语言编写。强大的工具也因使用情景、使用对象的不同，衍生出不同的Git工作流。 情景一：集中式工作流 情景二：功能分支工作流 情景三：Gitflow工作流 情景四：Forking工作流 情景一：集中式工作流1. 老A初始化工程 老A在服务器上新建了一个repository（下文均以本人的github/git-workflow-story为例子） 12345mkdir git-workflow-story &amp;&amp; cd &quot;$_&quot;// 当然你也可以在bash里自定义 mkdir&amp;cd 等快捷命令git initgit remote add origin https://github.com/palmerye/git-workflow-story.git 2. 阿B开始写故事 阿B的任务是在repo里写Readme(Markdown) 12345mkdir story-B &amp;&amp; cd &quot;$_&quot;git clone https://github.com/palmerye/git-workflow-story.gitvi readme.md 于是阿B在readme里面写了一点东西，打算push到老A建的repo里。123456git add readme.mdgit commit -m &quot;这是阿B的第一次提交&quot;git push -u origin master// -u 参数用来初次push的时候指定默认upstream上游分支 3. 小C来啦 有一天，老A觉得阿B一个人忙不过来，找来小C来帮忙 上班第一天，小C就开始忙活，也打算在老A的repo里写点东西。 123mkdir story-C &amp;&amp; cd &quot;$_&quot;git clone https://github.com/palmerye/git-workflow-story.git 这个时候repo里已经有了阿B的第一次push的文件，小C突然发现有个错别字，就顺便改了。 12345git add readme.mdgit commit -m &quot;修改了一个错别字&quot;git push -u origin master 4. 冲突阿B下午又写了点东西，和之前一样，暂存/提交/推送，突然git push失败了（错误提示本地仓库落后于远端）。于是机智的阿B有了如下操作： 1git pull --rebase origin master 再次push的时候发现有冲突，于是去解决冲突。发现和小C改了同一个地方，于是自己修改完继续push。 git merge的冲突判定机制如下：先寻找两个commit的公共祖先，比较同一个文件分别在ours和theirs下对于公共祖先的差异，然后合并这两组差异。如果双方同时修改了一处地方且修改内容不同，就判定为合并冲突，依次输出双方修改的内容。 12345git add . git rebase --continuegit push origin master 故事完结 从此他们在一起过上了幸福的Coder生活。 由上面的故事我们可以看到，集中式工作流只有一条master分支，而且维护得干净一点，永远只有一条分支。多人协作的时候，推送前要确保自己本地状态和远端保持同步，因此要记得rebase。但局限就是，一条分支很难去管理多个开发状态，因此在集中式工作流的基础上，有了后文的功能分支工作流。 补充点东西 git pull 时，–rebase参数可以让分支更整洁 git pull前123 B1---B2 master /A---B---C origin/master 不加–rebase/相当于merge123 B1---B2 master / \A---B--------C origin/master 加上–rebase，告别合并点，让分支更整洁1A---B---C---B1---B2 master, origin/master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[扫盲笔记--H5视频直播]]></title>
      <url>%2F%E6%89%AB%E7%9B%B2%E7%AC%94%E8%AE%B0-H5%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%2F</url>
      <content type="text"><![CDATA[项目需要，这里做一个简单的笔记梳理 视频直播流程：采集端 ==&gt; 服务器端 ==&gt; 播放端 流程图用的一个Chrome插件，Gliffy Diagrams。 先把这些协议讲一讲1. RTMP（Real Time Messaging Protocol） RTMP是Adobe Systems公司为Flash播放器和服务器之间音频、视频和数据传输开发的开放协议。该协议基于TCP，是一个协议族，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。 工作原理：在RTMP协议中的基本数据单元称为Message（消息），在传输数据的过程中，Message会被拆分成更小快的Chunk（消息块）。 传输媒体流的过程：1.发送端将媒体数据封装成Message 2.再把Message切分成Chunk 3.基于TCP协议发送 4.接收端通过TCP收到Chunk 5.将Chunk重组成Message 6.对Message解包得到媒体数据 特点 延迟低 RTMP协议基于TCP底层通讯协议，属于长链接，收到数据后立即发送 延迟累积 还是因为基于TCP，丢包少（TCP重传机制）,网络差的时候服务器将包缓存，等到网络好的时候在一并发给服务器。 隐私性理想 2. HLS（HTTP Live Streaming） 关键词：切片。 HLS协议规定: 视频的封装格式是TS。 视频的编码格式为H264,音频编码格式为MP3、AAC或者AC-3。 定义了用来存放流配置和路径的m3u8索引文件。 先来show一段基于HLS协议的视频播放code 1234567...&lt;div id=&quot;player&quot;&gt; &lt;video width=&quot;640&quot; height=&quot;320&quot; controls&gt; &lt;source src=&quot;http://..url../live/livestream.m3u8&quot; type=&quot;application/x-mpegURL&quot;&gt; &lt;/video&gt;&lt;/div&gt;... 如果要兼容所有浏览器，需要接第三方播放器，比如video.js 工作原理：把整个流切分成一个个基于HTTP的小文件（ts文件），用m3u8索引表来管理这些小切片。可以看到上面👆这段code中的source，是一个.m3u8文件，所以当视频播放的时候，video标签解析这个索引文件（动态更新），然后按序去找到对应的ts文件（真正存放视频数据的文件）并连续播放。 特点： 跨平台（ios、Android、pc） RTMP基于flash，ios不支持 基于HTTP，容易接CDN 实时性差（延迟一般在10s-30s左右） 由于流被切片下载，假设.m3u8索引列表里有n个ts文件，每个ts文件包含m秒视频内容，同时推流端又有新的流推上来，但拉流端才刚刚看到下载下来的切片流，所以延迟就是n*m秒。想要延迟小，理想就让n和m的值最小到1，几乎零延迟，由于HLS基于HTTP协议，所以随之而来的就是请求次数增加，server端压力大。因此要平衡取舍。 PS：苹果官方推荐的ts时长为10s，列表3个ts文件，因此会有大概30s的延迟。https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html 3.What duration should media files be? The main point to consider is that shorter segments result in more frequent refreshes of the index file, which might create unnecessary network overhead for the client. Longer segments will extend the inherent latency of the broadcast and initial startup time. A duration of 10 seconds of media per file seems to strike a reasonable balance for most broadcast content. 4.How many files should be listed in the index file during a continuous, ongoing session? The normal recommendation is 3, but the optimum number may be larger… 3. WebRTC（Web Real-Time Communication） 是一个支持网页浏览器进行实时语音对话或视频对话的 API。它于 2011 年 6 月 1 日开源并在 Google、Mozilla、Opera 支持下被纳入万维网联盟的 W3C 推荐标准。 浏览器兼容性 可以看到，截止目前（2017.2.14），WebRTC的兼容性还是惨不忍睹，只在PC端的Chrome比较好（毕竟是谷歌2010年以6820万美元收购Global IP Solutions公司而获得的一项技术）。不过风头火热，xxxx，指日可待。 工作原理简单的一句话就是，让浏览器提供JS的即时通信API。通过一系列的信令建立浏览器之间的信道，来传输音频视频数据。与WebSocket的区别就是，少了中间的WebSocket服务器。 其实没那么simple先来看看用WebRTC实现一场会议直播的正常流程 其实p2p（peer to peer）就能跑起来了 推流端（如Chrome浏览器）调用相关的媒体API来获取音视频源 中转的MCU服务器（不是说不需要么？因为chrome给超过10个用户推流的时候很容易崩），对音视频做一些简单的处理。 客户端（如Chrome）连接MCU，并获取媒体流。 之前在项目里用过声网的WebRTC的SDK，所以感觉这项技术还是牛honghong的。 4. HTTP-FLV （补充） 顾名思义，就是将音视频数据流封装成FLV，再通过HTTP协议传输给客户端。 特点 延时低（与RTMP媲美） 穿透性强（基于HTTP80端口通信） 可以使用HTTPS做加密通道 上面讲得差不多了，这里就做个小总结。 采集端(推流端)如开头的流程图中所述，一般常用的就是RTMP推流，因为延迟较小。 补充：几个主流的 web直播平台，几乎都是以HTTP-FLV为直播协议。 推荐一个推流工具：OBS Server端简单的说就是一台流媒体服务器，用来接收流和分发流。 e.g. 比如一台Nginx服务器，要扩展支持RTMP，用的较多是这个： https://github.com/arut/nginx-rtmp-module 播放端(拉流端) FlashPlayer浏览器支持（RTMP） h5的video标签（HLS） 火爆的flv.js（那个B站工资5000的大神，可惜走了）（HTTP-FLV） 实现了H5端对FLV格式的播放，终于解脱了臃肿的Flash。 说了这么多，大厂都有了视频直播的解决方案，直接拿来用也挺省心。 参考文章： http://www.cnblogs.com/luconsole/p/6079534.html https://www.nihaoshijie.com.cn/index.php/archives/615 这篇笔记做下来，真的是觉得视频这块领域很大呢，要想更深入还是需要花大力气学习的。肯定有很多不妥当的地方，希望多批评，文章也会持续更新…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web + Log = Blog]]></title>
      <url>%2FWeb-Log-Blog%2F</url>
      <content type="text"><![CDATA[Blog原来是这样来的 博客（英语：Blog，为Web Log的混成词），意指log on the web意即在网络上纪录，是一种由个人管理、张贴新的文章、图片或视频的网站或在线日记，用来纪录、抒发情感或分享信息。 From Wiki. 我为什么要写博客For 生存 自从看了阮一峰老师的Blog，我才知道什么叫全能；频繁的浏览他的Blog，我才意识到全能的背后是文章的高产。 *知识梳理，才知道自己哪里缺胳膊少腿 给别人一个爱批评你的机会 一不小心能帮到同行呢 信息整合，也许有一天，不需要再这里Google那里Baidu了，Local Search就能找到信息 扩大在圈子里的影响力 （打这几个字我都有点手抖） For 生活 有没有发现，年级大了，QQ空间没什么动态更新了，朋友圈发得少了，不易悲，也不易喜。 写一些经历和想法，也许能和visitors产生一些共鸣 用文字和图片记录下一些生活，常常翻翻，听说这样不会抑郁 我挺喜欢拍照，拿blog当个web相册也不错 关于这个博客一些东西 暂时搭建在github良心的Pages上（Repository） 如果你手滑点进去了，那就手滑star下吧 搭建于gh-pages分支。为什么不用palmerye.github.io?另有他用，其实没多大区别 Blog工具用的Hexo，主题是Next，自己稍做了一点修改 首页的封面图是用AI画的矢量图，从PCB到Code，也表示自己从硬件转型到软件的历程，每一段经历都很宝贵，值得珍惜。 该加的功能都加了，包括站点底下的PV和UV统计 或许上面👆这条是假的，我们的工作就是不断否定自己 日子如何，力量也如何。这句话出于《圣经·申命记》33:25 关于博客的目的，说到底还是一句话，利人利己 因为我觉得这样很酷。]]></content>
    </entry>

    
  
  
</search>
